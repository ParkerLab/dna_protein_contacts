import argparse
import re
import os
import sys
import gzip
import subprocess


def parse_arguments():
    # parse_arguments
    parser = argparse.ArgumentParser(description='Specify necessary input files')
    parser.add_argument('clstr', type=str, help='Path of the .clstr file generated by CD-HIT')
    parser.add_argument('representative_sequences', type=str, help='Path of CD-HIT representative sequences')
    parser.add_argument('annotations', type=str, help='Path containing all sequences and annotations')
    parser.add_argument('split_chain', type=str, help='Path to directory containing split PDB files')
    parser.add_argument('outfile', type=str, help='Path to output file')
    return parser.parse_args()


def pfile(m, f):
    f = open(f, 'a+')
    print(m, file=f)


def perr(m):
    # print to stderr
    print(m, file=sys.stderr)


def open_maybe_gzipped(f):
    # open gzipped files
    with open(f, 'rb') as test_read:
        byte1, byte2 = test_read.read(1), test_read.read(1)
        if byte1 and ord(byte1) == 0x1f and byte2 and ord(byte2) == 0x8b:
            f = gzip.open(f, mode='rt')
        else:
            f = open(f, 'rt')
        return f


def retrieve_sequences_and_annotations(annotated_sequences):
    """
    Generate dictionaries containing ID: annotation, and ID: sequence
    :param annotated_sequences: Iterable with oiginal parsed sequences + annotations
    :return annotations: Dictionary of format {identifier: annotation}
    :return sequences: Dictionary of format {identifier: sequence}
    """

    sequences = dict()
    annotations = dict()
    identifier = str()

    for i in range(0, len(annotated_sequences)):
        if i % 3 == 0:
            identifier = annotated_sequences[i][1:]  # identifier excludes the ">" at start of fasta description line

        if i % 3 == 1:
            sequences[identifier] = list(annotated_sequences[i])

        if i % 3 == 2:
            annotations[identifier] = list(annotated_sequences[i])

    return annotations, sequences


def generate_tm_score(pdb1, pdb2, split_chain):
    """
    Returns the TM score for two different sequences
    :param pdb1: pdb identifier for first pdb file
    :param pdb2: pdb identifier for the representative chain
    :param split_chain: path to split chain pdb files
    :return:
    """
    pdb1 = os.path.join(split_chain, pdb1+'.pdb')
    pdb2 = os.path.join(split_chain, pdb2+'.pdb')  # pdb files for representative sequences all exist

    if not os.path.exists(pdb1):
        return 0

    score_re = re.compile('TM-score\s+= (1|0)\.[0-9]+')
    num_re = re.compile('(1|0)\.[0-9]+')
    tmscore = "/home/collinwa/bin/./TMscore {} {}".format(pdb1, pdb2)
    result = str(subprocess.check_output(tmscore, shell=True))

    # sometimes scores don't exist, then don't merge
    tm_score = re.search(score_re, result).group(0) if re.search(score_re, result) else '0.0'

    return float(re.search(num_re, tm_score).group(0))


def transfer_annotations(sequence_clusters, annotations, sequences, split_chain):
    """
    Identify the representative protein sequence
    Go through the proteins in the cluster and calculate TM-Scores.
    If TM-Score < .5, ignore that sequence. If TM-Score > .5, then align the proteins, merge annotations,
    and delete the non-representative chain from the annotations dictionary.

    :param sequence_clusters:
    :param annotations:
    :param sequences:
    :return:
    """

    i = 0
    while i < len(sequence_clusters):
        current_cluster = []

        if re.search('Cluster', sequence_clusters[i]):
            i += 1
            while i < len(sequence_clusters) and re.search('Cluster', sequence_clusters[i]) is None :
                current_cluster.append(sequence_clusters[i])
                i += 1

        pdb_re = re.compile('[0-9][a-z0-9]{3}\_([A-Z]|[0-9])')  # regex for matching identifiers
        rep_re = re.compile('\*')  # regex for matching representative chain
        overlap_re = re.compile('[0-9]+:[0-9]+:[0-9]+:[0-9]+')
        representative_id = ''

        for line in current_cluster:
            if re.search(rep_re, line):
                representative_id = re.search(pdb_re, line).group(0)  # set the representative ID

        for line in current_cluster:
            if not re.search(rep_re, line):
                identifier = re.search(pdb_re, line).group(0)
                tm_score = generate_tm_score(identifier, representative_id, split_chain)

                if tm_score > .5:
                    # retrieve the coordinates for the overlaps of proteins with tm scores > .5
                    overlap = [int(x) for x in re.search(overlap_re, line).group(0).split(':')]

                    # CD-HIT uses 1-based coordinates, but Python used 0 based. Must transform them.
                    aligned_start = overlap[0] - 1
                    aligned_end = overlap[1] - 1
                    rep_start = overlap[2] - 1
                    rep_end = overlap[3] - 1

                    transfer = annotations[identifier]  # annotations for the aligned sequence
                    # fragment lengths for aligned and representative sequence
                    aligned_fragment_length = aligned_end - aligned_start + 1
                    rep_fragment_length = rep_end - rep_start + 1

                    # skip if aligned and representative sequence lengths are not equal
                    if aligned_fragment_length != rep_fragment_length:
                        continue

                    # transfer annotations to the representative chain
                    for j in range(0, rep_fragment_length):
                        if transfer[aligned_start + j] == '1':
                            annotations[representative_id][rep_start + j] = '1'

                    # remove the cluster member sequence from annotations
                    perr('{} with TM-Score of {} transferred and removed.'.format(identifier, tm_score))
                    annotations.pop(identifier, None)

                else:
                    # if TM Score < .5 (i.e. not in the same fold), no annotations are transferred
                    continue

    return annotations


if __name__ == '__main__':
    args = parse_arguments()
    sequence_clusters = [line.strip() for line in open_maybe_gzipped(args.clstr)]
    annotated_sequences = [line.strip() for line in open_maybe_gzipped(args.annotations)]
    representative_sequences = [line.strip() for line in open_maybe_gzipped(args.representative_sequences)]
    pdb_basedir = args.split_chain
    outfile = args.outfile
    perr('Finished loading clusters and annotations.')

    annotations, sequences = retrieve_sequences_and_annotations(annotated_sequences)
    perr('Number of annotated sequences: {}'.format(len(annotations)))

    annotations = transfer_annotations(sequence_clusters, annotations, sequences, pdb_basedir)
    perr('Number of annotated sequences after annotation transfer: {}'.format(len(annotations)))

    for key in annotations:
        pfile('>{}\n{}\n{}'.format(key, ''.join(sequences[key]), ''.join(annotations[key])), outfile)
